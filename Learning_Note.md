![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.zzvips.com%2Fuploads%2Fallimg%2F200408%2F202UaW2-2.png&refer=http%3A%2F%2Fwww.zzvips.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1673159394&t=8cac6816b69e436e78e4668bb2f35d9c)
这是 **penguin7210** 的**Linux**大作业。

## 1 Linux课程中的学习笔记

### 1.1 shell语法
命令 选项 参数

命令：整条shell命令的主体

选项：会影响会微调整个命令的行为

参数：命令作用的对象

- **自动补全**

- **快捷键**

   - ctrl+C：终止前台运行的程序
   - ctrl+D：相当于exit
   - ctrl+L：清屏
   - ctrl+A：光标移到命令行的前端
   - ctrl+E：光标移到命令行的后端
   - ctrl+K：删除光标后的所有字符
   - ctrl+U：删除光标前的所有字符

### 1.2 文件管理
#### 1.2.1 文件目录结构
![](https://img-blog.csdnimg.cn/20200823162705516.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTcxODk1,size_16,color_FFFFFF,t_70#pic_center)

### 1.3 输出重定向

1. 正确输出：> 等价于1> ：将目标输出到文件中，会覆盖 >>等价于1>>： 将目标输出到文件中，追加到文件后

2. 错误输出：2>将错误命令输出到文件中 ，有覆盖作用 ，2>>： 将错误命令输出到文件中 ，追加到文件后*
3. &> 不管是正确输出还是错误输出都重定向到一个文件中
### 1.4 输入重定向
1. < 或者 0< 将文件中的内容作为CMD的输入
command file2 将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。

2. 重定向符号<<，这个符号的作用是使用特定的分界符作为命令输入的结束标志，而不使用 Ctrl+D 键。
### 1.5 管道
**操作符**是：”**|**”,它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入。
### 1.6 awk命令讲解
**awk是行处理器:**

相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息

**awk处理过程:**

1. awk使用一行作为输入，并将这一行赋给内部变量$0，每一行也可称为一个记录，以换行符（RS）结束；
2. 每行被间隔符：（默认为空格活制表符）分解成字段，每个字段储存在已编好的变量中，从$1开始
3. awk使用print函数打印字段，打印出来的字段以空格分隔，因为$1,$3之间有一个逗号，逗号比较特殊，它映射为另一个内部变量，称为输出字段分隔符OFS，OFS默认为空格
4. awk处理完一行后，将从文件中获取另一行，并将其储存在$0中，覆盖原来的内容，然后将新的字符串分隔成字段并进行处理，该过程将持续到所有行处理完成。
```
awk命令形式:  awk [-F|-f|-v] ‘BEGIN{} //{command1; command2} END{}’ file
[-F|-f|-v]   大参数，-F指定分隔符，-f调用脚本，-v定义变量 var=value
'  '          引用代码块
BEGIN   初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符，注意：如果要手动设置分隔符，在分隔符开始要用BEGIN
//           匹配代码块，可以是字符串或正则表达式
{}           命令代码块，包含一条或多条命令
；          多条命令使用分号分隔
END      结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息
**特殊要点:**
$0           表示整个当前行，整行全部内容，awk '{print $0}' copy.txt
$1           每行第一个字段，类似的$2  $3 $4 $5
NF          字段数量变量   cat /etc/passwd | awk -F: '{print NF}'，即为一共有多少列全部打印出来
$NF        表示打印最后一列，如果要往前则是$(NF-1)
NR          每行的记录号，多文件记录递增，比如打印1到5行，则是awk 'NR==1,NR==5{print $0}'
FNR        与NR类似，不过多文件记录不递增，每个文件都从1开始
\t            制表符
\n           换行符
FS          BEGIN时定义分隔符，可以理解为F的作用
OFS       输出字段分隔符， 默认也是空格，可以改为制表符等,意思是将输出字段按指定分隔符衔接
~            匹配，与==相比不是精确比较
!~           不匹配，不精确比较
==         等于，必须全部相等，精确比较
!=           不等于，精确比较
&&　     逻辑与
||             逻辑或
+            匹配时表示1个或1个以上
/[0-9][0-9]+/   两个或两个以上数字
/[0-9][0-9]*/    一个或一个以上数字
FILENAME 文件名
ORS         输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕
RS       输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)
-F'[:#/]'   定义三个分隔符
例如：awk ' $6>=20{ print $1},在输出时候先进行判断

```
### 1.7 sed命令
sed是一种几乎包括在所有unix平台的轻量级流编辑器，sed主要是用来将数据进行选取，替换，删除，新增的命令。
```
**语法：sed  [选项]  ‘[动作]’  文件名**
选项：
-n：一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕
-e：允许对输入数据应用多条sed命令编辑
-i： 用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出

动作：
a\ ：追加，在当前行后添加一行或多行
c \：行替换，用c后面的字符串替换原数据行
i \：插入，在当前行前插入一行或者多行
d：删除指定行
p：打印指定行
s：字符串替换，格式为  “行范围s/旧字符/新字符/g”
```
### 1.8 命令排序
1. **&& || 具备逻辑判断**

command1 && command2 只有在command1成功执行后才会执行command2
command1 || command2 在command1没有成功执行时执行command2

2. **；不具备逻辑判断**

### 1.9 yum相关命令：
```
yum clean all    #清理yum缓存
yum makecache    #缓存软件包信息
yum repolist    #查询yum源信息
yum search 软件名      #查询软件
yum provides  软件名     #查看软件属于哪个文件    
yum list          # yum list显示所有已经安装和可以安装的程序包
yum list 软件名  #可以查看相关的软件信息，是否安装
如果是yum安装的话可以使用
yum list installed | grep 软件名
```
### 1.10 进程管理
#### **ps命令**

ps 命令是最常用的监控进程的命令，通过此命令可以查看系统中所有运行进程的详细信息。

ps 命令的基本格式如下：
```
[root@localhost ~]# ps aux
#查看系统中所有的进程，使用 BS 操作系统格式
[root@localhost ~]# ps -le
#查看系统中所有的进程，使用 Linux 标准命令格式
选项：
a：显示所有包括所有终端的进程；
u：显示进程的归属用户及内存的使用情况；
x：显示没有控制终端的进程；
-a: 显示当前终端下执行的进程；
-l：长格式显示更加详细的信息；
-e：显示所有进程；
-f: 显示所有进程的父进程
可以看到，ps 命令有些与众不同，它的部分选项不能加入"-"，比如命令"ps aux"，其中"aux"是选项，但是前面不能带“-”。

[root@localhost ~]# ps aux
#查看系统中所有的进程
USER PID %CPU %MEM  VSZ  RSS   TTY STAT START TIME COMMAND
root   1  0.0  0.2 2872 1416   ?   Ss   Jun04 0:02 /sbin/init
root   2  0.0  0.0    0    0   ?    S   Jun04 0:00 [kthreadd]
root   3  0.0  0.0    0    0   ?    S   Jun04 0:00 [migration/0]
root   4  0.0  0.0    0    0   ?    S   Jun04 0:00 [ksoftirqd/0]
…省略部分输出…
USER	该进程是由哪个用户产生的。
PID	进程的 ID。
%CPU	该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。
%MEM	该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。
VSZ	该进程占用虚拟内存的大小，单位为 KB。
RSS	该进程占用实际物理内存的大小，单位为 KB。
TTY	该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。
STAT	进程状态。常见的状态有以下几种：
-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。
-R：该进程正在运行。
-S：该进程处于睡眠状态，可被唤醒。
-T：停止状态，可能是在后台暂停或进程处于除错状态。
-W：内存交互状态（从 2.6 内核开始无效）。
-X：死掉的进程（应该不会出现）。
-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。
-<：高优先级（以下状态在 BSD 格式中出现）。
-N：低优先级。
-L：被锁入内存。
-s：包含子进程。
-l：多线程（小写 L）。
-+：位于后台。
START	该进程的启动时间。
TIME	该进程占用 CPU 的运算时间，注意不是系统时间。
COMMAND	产生此进程的命令名。
```
### 1.11 在vi和vim模式下的命令
```
i		#进入输入模式
a		#进入输入模式 光标前进一位
ESC		#退出输入模式
wq		#保存并退出
q		#退出
q!		#强制退出

#复制
yy(正常模式)			#拷贝当前行   
p(正常模式)			#粘贴
5yy(正常模式)			#拷贝当前行向下5行

#删除
dd(正常模式)			#删除一行
5dd(正常模式)			#删除当前行向下的5行

#查找
/hello + 回车(正常模式)   #查找关键字hello
n(正常模式)			#查找下一个

#文件的行号
:set nu(命令模式)		#设置行号
:set nonu(命令模式)	#取消行号

#跳转到最末行
G(正常模式)
#跳转到最首行
gg(正常模式)

#撤销
u(正常模式)
```
### 1.12 用户管理
#### 1.12.1添加用户
```
useradd [选项] 用户名    #[选择]是参数
useradd -d 新的用户名     #给新创建的用户指定家目录  ConterOS
useradd -m 新的用户名	 #给新创建的用户指定家目录  Unbutu
```

#### 1.12.2 删除用户
```
userdel 用户名   #删除用户  但是保存用户家目录
userdel -r 用户名	#删除用户  同时删除用户家目录
#删除用户时，一般不将用户家目录删除
```

#### 1.12.3 设置密码
```
passwd 用户名
```
#### 1.12.4 查看用户
```
w     #查看用户列表
id 用户名	#查看指定用户信息
whoami		#查看当前用户名
who am i	#查看当前登录用户名
```
#### 1.12.5 切换用户
```
su - 用户名
```
#### 1.12.6 新增组
```
groupadd 组名
useradd -g 用户组 用户名   #增加一个用户的时候直接将他指定到一个组
```
#### 1.12.7 删除组
```
groupdel 组名
```
#### 1.12.8修改用户的组
```
usermod -g 用户组 用户名
```
